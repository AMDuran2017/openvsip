<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>2.7. Parameter Enumerations for Signal Processing</title><link rel="stylesheet" href="cs.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"><link rel="home" href="index.html" title="Sourcery VSIPL++"><link rel="up" href="datatypes.html" title="Chapter 2. Basic VSIPL++ Data Types and Constants"><link rel="prev" href="ch02s06.html" title="2.6. Tensor Objects"><link rel="next" href="operations.html" title="Chapter 3. Overview of VSIPL++ Operations"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2.7. Parameter Enumerations for Signal Processing</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch02s06.html">Prev</a> </td><th width="60%" align="center">Chapter 2. Basic VSIPL++ Data Types and Constants</th><td width="20%" align="right"> <a accesskey="n" href="operations.html">Next</a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id276883"></a>2.7. Parameter Enumerations for Signal Processing</h2></div></div></div><p>VSIPL++ defines several enumerations to aid in the construction and
  use of signal processing functions and objects.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="classref_alg_hint_type"></a>2.7.1. alg_hint_type</h3></div></div></div><a class="indexterm" name="id276901"></a><p>Use to indicate a preference on type of algorithm, if library has
   multiple algorithms. If library does not have multiple algorithms,
   preference will be ignored.</p><div class="variablelist"><dl><dt><span class="term">alg_time</span></dt><dd><p>Prefer fastest algorithm. <a class="indexterm" name="id276927"></a></p></dd><dt><span class="term">alg_space</span></dt><dd><p>Prefer most memory efficient algorithm. <a class="indexterm" name="id276948"></a></p></dd><dt><span class="term">alg_noise</span></dt><dd><p>Prefer most accurate algorithm. <a class="indexterm" name="id276968"></a></p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="classref_bias_type"></a>2.7.2. bias_type</h3></div></div></div><a class="indexterm" name="id276990"></a><p>Some filters, for example <code class="type">
   Correlation</code>, can scale the output. Control this
   behavior with <span class="bold"><strong>
     <code class="type">bias_type</code>
    </strong></span>.</p><div class="variablelist"><dl><dt><span class="term">biased</span></dt><dd><p>Do not scale. <a class="indexterm" name="id277028"></a></p></dd><dt><span class="term">unbiased</span></dt><dd><p>Divide each output value by the number of input values. <a class="indexterm" name="id277049"></a></p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="classref_mat_op_type"></a>2.7.3. mat_op_type</h3></div></div></div><a class="indexterm" name="id277070"></a><p>Linear equation solvers and generalized matrix products use 
   <span class="bold"><strong><code class="type">mat_op_type</code></strong></span> to
   indicate the matrix operation type.
   </p><div class="variablelist"><dl><dt><span class="term">mat_ntrans</span></dt><dd><p>Indicates the matrix should not be transposed.<a class="indexterm" name="id277103"></a></p></dd><dt><span class="term">mat_trans</span></dt><dd><p>Indicates the matrix should be transposed.<a class="indexterm" name="id277124"></a></p></dd><dt><span class="term">mat_herm</span></dt><dd><p>Indicates the Hermitian transpose or conjugate transpose
      of the matrix should be taken.
      <a class="indexterm" name="id277146"></a></p></dd><dt><span class="term">mat_conj</span></dt><dd><p>Indicates the conjugate of the matrix should be taken.
      <a class="indexterm" name="id277168"></a></p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="classref_obj_state"></a>2.7.4. obj_state</h3></div></div></div><a class="indexterm" name="id277189"></a><p>Some filters, for example <code class="type">Fir</code>, can
   maintain state between invocations. Use <span class="bold"><strong>
     <code class="type">obj_state</code>
    </strong></span> to control this behavior.</p><div class="variablelist"><dl><dt><span class="term">state_no_save</span></dt><dd><p>Do not save state between successive invocation of filter.
      <a class="indexterm" name="id277228"></a></p></dd><dt><span class="term">state_save</span></dt><dd><p>Save state between successive invocations of filter so that output
      is continuous. <a class="indexterm" name="id277250"></a></p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="classref_product_side_type"></a>2.7.5. product_side_type</h3></div></div></div><a class="indexterm" name="id277271"></a><p>Linear equation solvers, specifically 
   <code class="type">chold</code>, <code class="type">qrd</code> and <code class="type">svd</code>, 
   use <span class="bold"><strong><code class="type">product_side_type</code></strong></span> to
   indicate whether to use left or right multiplication in matrix products.
   </p><div class="variablelist"><dl><dt><span class="term">mat_lside</span></dt><dd><p>Indicates <code class="code">prod(A, B)</code> yields the product 
      <code class="varname">A</code> <code class="varname">B</code>.<a class="indexterm" name="id277324"></a></p></dd><dt><span class="term">mat_rside</span></dt><dd><p>Indicates <code class="code">prod(A, B)</code> yields the product 
      <code class="varname">B</code> <code class="varname">A</code>.<a class="indexterm" name="id277356"></a></p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="classref_mat_uplo"></a>2.7.6. mat_uplo</h3></div></div></div><a class="indexterm" name="id277377"></a><p>The Cholesky linear equation solver <code class="type">chold</code> uses 
   <span class="bold"><strong><code class="type">mat_uplo</code></strong></span> to indicate which 
   half of a symmetric or Hermitian matrix is referenced.
   </p><div class="variablelist"><dl><dt><span class="term">lower</span></dt><dd><p>Indicates the lower LU decomposition is performed.
      <a class="indexterm" name="id277413"></a></p></dd><dt><span class="term">upper</span></dt><dd><p>Indicates the upper LU decomposition is performed.
      <a class="indexterm" name="id277435"></a></p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="classref_return_mechanism_type"></a>2.7.7. return_mechanism_type</h3></div></div></div><a class="indexterm" name="id277456"></a><p>Fast Fourier Transforms and Linear equation solvers, specifically 
   <code class="type">chold</code>, <code class="type">lud</code>, <code class="type">qrd</code> and <code class="type">svd</code>, 
   use <span class="bold"><strong><code class="type">return_mechanism_type</code></strong></span> to 
   indicate the return mechanism format for matrices containing results.
   The former is generally easier to code, though the latter is generally faster 
   and preferred for larger data sets.</p><div class="variablelist"><dl><dt><span class="term">by_value</span></dt><dd><p>Indicates a function returns a computed value. <a class="indexterm" name="id277504"></a></p></dd><dt><span class="term">by_reference</span></dt><dd><p>Indicates a function requires a parameter where the computed 
      value is saved <a class="indexterm" name="id277525"></a></p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="classref_storage_type"></a>2.7.8. storage_type</h3></div></div></div><a class="indexterm" name="id277546"></a><p>Linear equation solvers, specifically <code class="type">qrd</code> and 
   <code class="type">svd</code>, use <code class="type">storage_type</code> to indicate 
   the storage format for decomposed matrices.</p><div class="variablelist"><dl><dt><span class="term">qrd_nosaveq</span></dt><dd><p>The <code class="type">qrd</code> object does not store Q. <a class="indexterm" name="id277586"></a></p></dd><dt><span class="term">qrd_saveq1</span></dt><dd><p>The <code class="type">qrd</code> object stores <code class="varname">Q</code> 
      using the same amount of space as the matrix given 
      for decomposition.<a class="indexterm" name="id277615"></a></p></dd><dt><span class="term">qrd_saveq</span></dt><dd><p>The <code class="type">qrd</code> object stores <code class="varname">Q</code> 
      using the same number of rows as the matrix given 
      for decomposition.<a class="indexterm" name="id277643"></a></p></dd><dt><span class="term">svd_uvfull</span></dt><dd><p>The <code class="type">svd</code> object stores all of the decomposed
      matrix.<a class="indexterm" name="id277668"></a></p></dd><dt><span class="term">svd_uvnos</span></dt><dd><p>The <code class="type">svd</code> object does not store the decomposed 
      matrix.<a class="indexterm" name="id277693"></a></p></dd><dt><span class="term">svd_uvpart</span></dt><dd><p>Given an <code class="varname">N</code> by <code class="varname">M</code>
      matrix, where <code class="code">p = min(M, N)</code>, the <code class="type">svd</code> object
      stores either the first <code class="varname">p</code> columns of 
      <code class="varname">U</code> (in the case of type <code class="type">ustorage</code>) or 
      the first <code class="varname">p</code> rows of 
      <code class="varname">V</code><sup>T</sup>
      or <code class="varname">V</code><sup>H</sup> (in the case of
      type <code class="type">vstorage</code>).<a class="indexterm" name="id277758"></a></p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="classref_support_region_type"></a>2.7.9. support_region_type</h3></div></div></div><a class="indexterm" name="id277780"></a><p><span class="bold"><strong>
     <code class="type">support_region_type</code>
    </strong></span> describes how to handle edge conditions for convolution and
   correlation filter objects.</p><div class="variablelist"><dl><dt><span class="term">support_full</span></dt><dd><p>Compute output wherever kernel has overlap with input support,
      treating values outside input as zero. <a class="indexterm" name="id277814"></a></p></dd><dt><span class="term">support_same</span></dt><dd><p>Compute output with same size as input, treating values outside
      input as zero. <a class="indexterm" name="id277835"></a></p></dd><dt><span class="term">support_min</span></dt><dd><p>Compute output only where kernel is entirely within the input
      support. <a class="indexterm" name="id277857"></a></p></dd><dt><span class="term">support_min_zeropad</span></dt><dd><p>Compute output only where kernel is entirely within the input
      support, with zero padding of output so sizes matches input. <a class="indexterm" name="id277879"></a></p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="classref_symmetry_type"></a>2.7.10. symmetry_type</h3></div></div></div><a class="indexterm" name="id277900"></a><p>The convolution algorithm uses a kernel whose size is determined from
   the size of a view of coefficients and from an indication of its symmetry
   given by a member of <span class="bold"><strong>
     <code class="type">symmetry_type</code>
    </strong></span>.</p><div class="variablelist"><dl><dt><span class="term">nonsym</span></dt><dd><p>The kernel has the same size as the coefficient view. <a class="indexterm" name="id277935"></a></p></dd><dt><span class="term">sym_even_len_odd</span></dt><dd><p>The kernel size is one less than twice the size of the coefficient
      view. <a class="indexterm" name="id277957"></a></p></dd><dt><span class="term">sym_even_len_even</span></dt><dd><p>The kernel size is twice the size of the coefficient view.
      <a class="indexterm" name="id277979"></a></p></dd></dl></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch02s06.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="datatypes.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="operations.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">2.6. Tensor Objects </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 3. Overview of VSIPL++ Operations</td></tr></table></div></body></html>
